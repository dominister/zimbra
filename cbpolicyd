#!/usr/bin/perl
# Author: Nigel Kukard  <nkukard@lbsd.net>
# Date: 2007-06-08
# Desc: Mail cluebringer policy daemon


use strict;
use warnings;


package cbp;


# Version
my $VERSION = "0.1";


use base qw(Net::Server::PreFork);
use Config::IniFiles;
use Data::Dumper;
use Getopt::Long;
use cbp::logging;
# Import module functions
use cbp::modules qw(
	loadFeature
	loadDatabase
	getFeatures
	getDatabases

	setLogger
);



# Override configuration
sub configure {
	my $self = shift;
	my $server = $self->{'server'};
	my $cfg;
	my $cmdline;
	my $inifile;


	# Set defaults
	$cfg->{'config_file'} = "/etc/cluebringer.conf";
	$server->{'timeout'} = 30;

	# Parse command line params
	%{$cmdline} = ();
	GetOptions(
			\%{$cmdline},
			"help",
			"config:s",
			"debug",
	);

	# Check for some args
	if ($cmdline->{'help'}) {
		$self->displayHelp();
		exit 0;
	}
	if ($cmdline->{'debug'}) {
		$server->{'log_level'} = 4;
		$cfg->{'debug'} = 1;
	}
	if (defined($cmdline->{'config'}) && $cmdline->{'config'} ne "") {
		$cfg->{'config_file'} = $cmdline->{'config'};
	}

	# Check config file exists
	if (! -f $cfg->{'config_file'}) {
		print(STDERR "ERROR: No configuration file '".$cfg->{'config_file'}."' found!\n");
		exit 1;
	}
	# Use config file, ignore case
	$inifile = new Config::IniFiles(
			-file => $cfg->{'config_file'},
			-nocase => 1
	);

	# Pull in params for the server
	my @params = (
			'log_level','log_file',
			'syslog_logsock', 'syslog_ident', 'syslog_logopt', 'syslog_facility',
			'port', 'host',
			'allow', 'deny', 'cidr_allow', 'cidr_deny',
			'pid_file', 
			'user', 'group',
			'timeout'
	);
	foreach my $param (@params) {
		my $val = $inifile->val('server', $param);
		$server->{$param} = $val if (defined($val));
	}
	# Small fixup if we going to be running in background
	if ((my $val = $inifile->val('server', 'background'))) {
		$server->{'setsid'} = 1;
	}

	# Pull in config params
	$cfg->{'features'} = $inifile->val('server', 'features');
	$cfg->{'databases'} = $inifile->val('server', 'databases');

	# Save our config and stuff
	$self->{'config'} = $cfg;
	$self->{'cmdline'} = $cmdline;
	$self->{'inifile'} = $inifile;
}



# Run straight after ->run
sub post_configure_hook {
	my $self = shift;
	my $cfg = $self->{'config'};


	setLogger(sub { $self->log(@_); } );

	# Check if we have a list of database types
	if (defined($cfg->{'databases'}) && $cfg->{'databases'} ne "") {
		$self->log(LOG_DEBUG,"[CBPOLICYD] Loading databases...");
		# Load modules
		foreach (split(/[, ]/,$cfg->{'databases'})) {
			loadDatabase($_,$self);
		}
		$self->log(LOG_DEBUG,"[CBPOLICYD] Loaded ".getDatabases()." databases.\n");
	}

	# Check if we have a feature list
	if (defined($cfg->{'features'}) && $cfg->{'features'} ne "") {
		$self->log(LOG_DEBUG,"[CBPOLICYD] Loading features...");
		# Load modules
		foreach (split(/[, ]/,$cfg->{'features'})) {
			loadFeature($_,$self);
		}
		$self->log(LOG_DEBUG,"[CBPOLICYD] Loaded ".getFeatures()." features.\n");
	}

}


# Initialize the child
sub child_init_hook {
	my $self = shift;
	my $server = $self->{'server'};
	my $cfg = $self->{'config'};


	# Create child specific contexts
	my @moduleList = getFeatures();
	foreach my $module (@moduleList) {
		$module->{'init'}($self) if (defined($module->{'init'}));
	}
}


# Destroy the child
sub child_finish_hook {
	my $self = shift;
	my $server = $self->{'server'};
	my $cfg = $self->{'config'};


	# Create child specific contexts
	my @moduleList = getFeatures();
	foreach my $module (@moduleList) {
		$module->{'finish'}($self) if (defined($module->{'finish'}));
	}
}


# Process requests we get
sub process_request {
	my $self = shift;
	my $server = $self->{'server'};


	my %request;

	# Eval to catch sig ALRM
	eval {
		local $SIG{'ALRM'} = sub { die "Timed Out!\n" };

		# Give connection $timeout time to do something
		my $previous_alarm = alarm($server->{'timeout'});

		# Loop with lines we get
		while (my $line = <STDIN>) {
			# If we don't get a pair, b0rk
			last unless $line =~ s/^([^=]+)=(.*)\n$//;
			$request{$1} = $2;

			# Reset timeout
			alarm($server->{'timeout'});
		}

		alarm($previous_alarm);
	};

	# Check results
	if ($@ =~ /timed out/i) {
		# FIXME: Log message we timed out
		$self->log(LOG_NOTICE,"[CBPOLICYD] Timed out!");
		return;
	} elsif (keys %request < 1) {
		$self->log(LOG_WARN,"[CBPOLICYD] Didn't get any key pairs");
	} else {
		# Sanitize data
		$request{'sender'} = lc($request{'sender'}) if (defined($request{'sender'}));
		$request{'recipient'} = lc($request{'recipient'}) if (defined($request{'recipient'}));
		# Internal data
		$request{'_timestamp'} = time();
		($request{'_domain'} = $request{'recipient'}) =~ s/[^@]+@//;


		$self->log(LOG_DEBUG,"[CBPOLICYD:$$] Request:\n".Dumper(\%request));

		# Check the data we have
		$self->do_work(\%request);
		# Grab result & check, DUNNO if no data
		my $res = "action=DUNNO";
		print("$res\n");
	}

	print("\n");
}


# This is where the actual processing & checking of modules takes place
sub do_work {
	my ($self,$data) = @_;


	my @moduleList = getFeatures();
	foreach my $module (@moduleList) {
		my $res = $module->{'check'}($data);
		# This means we must just carry on
		if (!defined($res)) {
			$self->log(LOG_ERR,"Ok ... we got undef, do nothing");
			next;

		# REJECT
		} elsif ($res =~ /^action=REJECT/i) {
			$self->log(LOG_ERR,"Ok ... we must reject");
		
		# DEFER_IF_PERMIT
		} elsif ($res =~ /^action=DEFER_IF_PERMIT/i) {
			$self->log(LOG_ERR,"Ok ... we must defer if we going to permit");
		
		# OK
		} elsif ($res =~ /^action=OK/i) {
			$self->log(LOG_ERR,"Ok ... total whitelisting");

		}
	}
}


# Slightly better logging
sub log {
	my ($self,$level,$msg) = @_;


	$self->SUPER::log($level,"$$ => ".$msg);
}


# Display help
sub displayHelp {
	print(STDERR<<EOF);

Usage: $0 [args]
    --config=<file>        Configuration file
    --debug                Put into debug mode

EOF
}


print(STDERR "ClueBringer v$VERSION - Copyright (c) 2007 LinuxRulz\n");


__PACKAGE__->run;


1;
# vim: ts=4
