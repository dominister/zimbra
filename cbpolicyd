#!/usr/bin/perl
# Cluebringer policy daemon
# Copyright (C) 2007, Nigel Kukard  <nkukard@lbsd.net>
# Copyright (C) 2008, LinuxRulz
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


use strict;
use warnings;


package cbp;


# Version
my $VERSION = "2.0.1a";


use base qw(Net::Server::PreFork);
use Config::IniFiles;
use Data::Dumper;
use Getopt::Long;

use cbp::logging;

use cbp::dblayer;
use cbp::dbilayer;
use cbp::cache;

use cbp::policies qw(getPolicy);


# Override configuration
sub configure {
	my $self = shift;
	my $server = $self->{'server'};
	my $cfg;
	my $cmdline;
	my $inifile;


	# Set defaults
	$cfg->{'config_file'} = "/etc/cluebringer.conf";
	$server->{'timeout'} = 120;

	# Parse command line params
	%{$cmdline} = ();
	GetOptions(
			\%{$cmdline},
			"help",
			"config:s",
			"debug",
	);

	# Check for some args
	if ($cmdline->{'help'}) {
		$self->displayHelp();
		exit 0;
	}
	if ($cmdline->{'debug'}) {
		$server->{'log_level'} = 4;
		$cfg->{'debug'} = 1;
	}
	if (defined($cmdline->{'config'}) && $cmdline->{'config'} ne "") {
		$cfg->{'config_file'} = $cmdline->{'config'};
	}

	# Check config file exists
	if (! -f $cfg->{'config_file'}) {
		print(STDERR "ERROR: No configuration file '".$cfg->{'config_file'}."' found!\n");
		exit 1;
	}
	
	# Use config file, ignore case
	tie my %inifile, 'Config::IniFiles', (
			-file => $cfg->{'config_file'},
			-nocase => 1
	) or die "Failed to open config file '".$cfg->{'config_file'}."': $!";
	# Copy config
	my %config = %inifile;
	untie(%inifile);


	# Pull in params for the server
	my @server_params = (
			'log_level','log_file',
			'syslog_logsock', 'syslog_ident', 'syslog_logopt', 'syslog_facility',
			'port', 'host',
			'allow', 'deny', 'cidr_allow', 'cidr_deny',
			'pid_file', 
			'user', 'group',
			'timeout'
	);
	foreach my $param (@server_params) {
		$server->{$param} = $config{'server'}{$param} if (defined($config{'server'}{$param}));
	}
	
	# Small fixup if we going to be running in background
	if ((my $val = $config{'server'}{'background'})) {
		$server->{'setsid'} = 1;
	}

	# Split off modules
	if (!defined($config{'server'}{'modules'})) {
		$self->log(LOG_WARN,"Server configuration error: 'modules' not found");
		exit 1;
	}
	$cfg->{'module_list'} = $config{'server'}{'modules'};
	foreach my $module (@{$cfg->{'modules_list'}}) {
		$module =~ s/\s+//g;
	}

	# Save our config and stuff
	$self->{'config'} = $cfg;
	$self->{'cmdline'} = $cmdline;
	$self->{'inifile'} = \%config;
}



# Run straight after ->run
sub post_configure_hook {
	my $self = shift;


	$self->log(LOG_NOTICE,"Initializing system modules.");
	cbp::config::Init($self);
	# Init caching engine
	cbp::cache::Init($self);
	$self->log(LOG_NOTICE,"System modules initialized.");


	$self->log(LOG_NOTICE,"Module load started...");
	# Load modules
	foreach my $module (@{$self->{'config'}{'module_list'}}) {
		# Load module
		my $res = eval("
			use cbp::modules::$module;
			plugin_register(\$self,\"$module\",\$cbp::modules::${module}::pluginInfo);
		");
		if ($@ || (defined($res) && $res != 0)) {
			$self->log(LOG_WARN,"WARNING: Error loading plugin $module ($@)");
		}
	}

	$self->log(LOG_NOTICE,"Module load done.");
}


# Register plugin info
sub plugin_register {
	my ($self,$module,$info) = @_;


	# If no info, return
	if (!defined($info)) {
		$self->log(LOG_WARN,"WARNING: Plugin info not found for module => $module");
		return -1;
	}

	# Set real module name & save
	$info->{'Module'} = $module;
	push(@{$self->{'modules'}},$info);

	# If we should, init the module
	if (defined($info->{'init'})) {
			$info->{'init'}($self);
	}


	return 0;
}


# Initialize child
sub child_init_hook
{
	my $self = shift;

	
	$self->SUPER::child_init_hook();
	
	$self->log(4,"Starting up caching engine");
	cbp::cache::connect($self);

	# Init system stuff
	$self->{'client'}->{'dbh'} = cbp::dbilayer::Init($self);
	if (!defined($self->{'client'}->{'dbh'})) {
		$self->log(LOG_WARN,"Failed to Initialize: ".cbp::dbilayer::internalErr()." ($$)");
		die;
	}
	if ($self->{'client'}->{'dbh'}->connect()) {
		$self->log(LOG_WARN,"Failed to connect to database: ".$self->{'client'}->{'dbh'}->Error()." ($$)");
		die;
	}

}




# Destroy the child
sub child_finish_hook {
	my $self = shift;
	my $server = $self->{'server'};

	$self->SUPER::child_init_hook();
	
	$self->log(LOG_DEBUG,"Shutting down caching engine ($$)");
	cbp::cache::disconnect($self);
}


# Process requests we get
sub process_request {
	my $self = shift;
	my $server = $self->{'server'};


	# Setup database handle
	cbp::dblayer::setHandle($self->{'client'}->{'dbh'});

	my %request;

	# Eval to catch sig ALRM
	eval {
		local $SIG{'ALRM'} = sub { die "Timed Out!\n" };

		# Give connection $timeout time to do something
		my $previous_alarm = alarm($server->{'timeout'});

		# Loop with lines we get
		while (my $line = <STDIN>) {
			# If we don't get a pair, b0rk
			last unless $line =~ s/^([^=]+)=(.*)\n$//;
			$request{$1} = $2;

			# Reset timeout
			alarm($server->{'timeout'});
		}

		alarm($previous_alarm);
	};

	# Check results
	if ($@ =~ /timed out/i) {
		# FIXME: Log message we timed out
		$self->log(LOG_NOTICE,"[CBPOLICYD] Timed out!");
		return;
	} elsif (keys %request < 1) {
		$self->log(LOG_WARN,"[CBPOLICYD] Didn't get any key pairs");
	} else {
		# Sanitize data
		$request{'sender'} = lc($request{'sender'}) if (defined($request{'sender'}));
		$request{'recipient'} = lc($request{'recipient'}) if (defined($request{'recipient'}));
		# Internal data
		$request{'_timestamp'} = time();
		($request{'_domain'} = $request{'recipient'}) =~ s/[^@]+@//;


		# Pull in policy, by this time we should have all the info we need
		if ($request{'protocol_state'} eq "RCPT") {
			my $policy = getPolicy($request{'client_address'},$request{'sender'},$request{'recipient'});
			if (!defined($policy)) {
				$self->log(LOG_ERR,"[CBPOLICYD] Failed to retrieve policy: ".cbp::policies::Error());
			}
			$request{'_policy'} = $policy;


		# Restore policies	
		} elsif ($request{'protocol_state'} eq "END-OF-MESSAGE") {
			my $sth = DBSelect("
				SELECT
					Recipient,Policies
				FROM
					session_tracking
				WHERE
					Instance = ".DBQuote($request{'instance'})."
			");
			my %rawPolicies;
			my %recipientToPolicy;
			# Build policy str list and recipients list
			while (my $row = $sth->fetchrow_hashref()) {
				# Loop with policies
				foreach my $policy (split(/;/,$row->{'Policies'})) {
					my ($prio,$pids) = ( $policy =~ /(\d+)=(.*)/ );
					foreach my $pid (split(/,/,$pids)) {
						$rawPolicies{$prio}{$pid} = 1;
						push(@{$recipientToPolicy{$prio}{$row->{'Recipient'}}},$pid);
					}
				}
			}
			DBFreeRes($sth);

			# Build final policy list
			my $policyHash;
			foreach my $prio (keys %rawPolicies) {
				$policyHash->{$prio} = [ keys %{$rawPolicies{$prio}} ] ;
			}

			$request{'_policy'} = $policyHash;
			$request{'_recipient_policy'} = \%recipientToPolicy;
		}

#		$self->log(LOG_DEBUG,"[CBPOLICYD:$$] Request:\n".Dumper(\%request));
#		$self->log(LOG_DEBUG,"[CBPOLICYD:$$] Policies:\n".Dumper($request{'_policy'}));

		# Check the data we have
		my $verdict = $self->do_work(\%request);

		# Check if state is RCPT and we not rejecting, dropping or redirecting message
		if ($request{'protocol_state'} eq "RCPT" && !($verdict =~ /action=(REJECT|DISCARD|REDIRECT)/)) {
			# SAVE POLICY DATE PER RECEIPT, WE WANT TO RESTORE FOR THE E-O-M

			my $policyStr;
			foreach my $priority (keys %{$request{'_policy'}}) {
				$policyStr .= sprintf('%s=%s;',$priority,join(',',@{$request{'_policy'}->{$priority}}));
			}

			# Chop off trailing ;
			chop($policyStr) if (defined($policyStr));

			# Record tracking info
			my $sth = DBDo("
					INSERT INTO session_tracking 
						(Instance,Timestamp,Recipient,Policies) 
					VALUES
						(
							".DBQuote($request{'instance'}).",
							".DBQuote($request{'_timestamp'}).",
							".DBQuote($request{'recipient'}).",
							".DBQuote($policyStr)."
						)
			");
			if (!$sth) {
				$self->log(LOG_ERR,"[CBPOLICYD] Failed to record sessing tracking info: ".cbp::dblayer::Error());
			}

		# When we done and we got E-O-M, nuke tracking
		} elsif ($request{'protocol_state'} eq "END-OF-MESSAGE") {
			my $sth = DBDo("
					DELETE FROM 
						session_tracking 
					WHERE
						Instance = ".DBQuote($request{'instance'})."
			");
			if (!$sth) {
				$self->log(LOG_ERR,"[CBPOLICYD] Failed to remove sessing tracking info: ".cbp::dblayer::Error());
			}
		}
		
		# Grab result & check, DUNNO if no data
		print("$verdict\n");
		print("\n");

	}


}


# This is where the actual processing & checking of modules takes place
sub do_work {
	my ($self,$data) = @_;


	# Set default result
	my $result = "DUNNO";

	# Loop with modules
	foreach my $module (@{$self->{'modules'}}) {
		
		# Run check
		my ($verdict,$verdict_data) = $module->{'check'}($self,$data);

		# Next if no verdict
		next if (!$verdict);

		# HOLD
		if ($verdict =~ /^hold$/i) {
			# Set verdict data
			$verdict_data = "Policy hold" if (!defined($verdict_data));
			$result = "HOLD $verdict_data";
		
		# REJECT
		} elsif ($verdict =~ /^reject$/i) {
			# Set verdict data
			$verdict_data = "Policy rejection" if (!defined($verdict_data));
			$result = "REJECT $verdict_data";
		
		# DISCARD
		} elsif ($verdict =~ /^discard$/i) {
			# Set verdict data
			$verdict_data = "Policy discard" if (!defined($verdict_data));
			$result = "DISCARD $verdict_data";
		
		# FILTER
		} elsif ($verdict =~ /^filter$/i) {
			# Sanity check
			if (!defined($verdict_data) || $verdict_data eq "") {
				$self->log(LOG_ERR,"[CBPOLICYD] Verdict data returned from module '".$module->{'name'}."' for FILTER is invalid");
				next;
			}
			# Set verdict data
			$result = "FILTER $verdict_data";
		
		# REDIRECT
		} elsif ($verdict =~ /^redirect$/i) {
			# Sanity check
			if (!defined($verdict_data) || $verdict_data eq "") {
				$self->log(LOG_ERR,"[CBPOLICYD] Verdict data returned from module '".$module->{'name'}."' for REDIRECT is invalid");
				next;
			}
			# Set verdict data
			$result = "REDIRECT $verdict_data";
		
		# OK
		} elsif ($verdict =~ /^ok/i) {
			$self->log(LOG_ERR,"Ok ... total whitelisting");
			# Set verdict data
			$result = "OK";

		}
	}

	$self->log(LOG_ERR,"Policy Result: $result");

	# Make sure we have no newline
	chomp($result);

	# Return result
	return "action=$result";
}


# Initialize child
sub server_exit
{
	my $self = shift;

	
	$self->log(2,"Destroying system modules.");
	# Destroy cache
	cbp::cache::Destroy($self);
	$self->log(2,"System modules destroyed.");

	$self->SUPER::server_exit();
}



# Slightly better logging
sub log
{
	my ($self,$level,$msg,@args) = @_;
	$self->SUPER::log($level,"[".$self->log_time." - $$] $msg",@args);
}


# Display help
sub displayHelp {
	print(STDERR<<EOF);

Usage: $0 [args]
    --config=<file>        Configuration file
    --debug                Put into debug mode

EOF
}


print(STDERR "ClueBringer v$VERSION - Copyright (c) 2007-2008 LinuxRulz\n");


__PACKAGE__->run;


1;
# vim: ts=4
